package main

import (
	"fmt"
	"github.com/joho/godotenv"
	"github.com/gin-gonic/gin"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
	"log"
	"os"
	"github.com/gin-contrib/cors"
	{{ range  $key, $val := .Imports }} "{{ $key }}" {{end}}
)
// MODELS
{{range .ModelsGo}}
type {{.Name|snakeToCamel}} struct {
{{range .Fields}} {{ .Name|snakeToCamel }} {{ .GoType }} `json:"{{ .Name }}"`
{{end}}}

func ({{.Name|snakeToCamel}}) TableName() string {
	return "{{.Name}}"
}
{{end}}
{{range .RelationsGo}}
type {{.Name|snakeToCamel}} struct {
{{range .Fields}} {{ .Name|snakeToCamel }} {{ .GoType }} `json:"{{ .Name }}"`
{{end}}}
func ({{.Name|snakeToCamel}}) TableName() string {
	return "{{.Name}}"
}
{{end}}
// Value objects
{{range .VoGo}}
type {{.Name|snakeToCamel}} struct {
{{range .Fields}} {{ .Name|snakeToCamel }} {{ .GoType }}
{{end}}}
{{end}}

func main() {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}
	dbuser := os.Getenv("DB_USER")
	dbpass := os.Getenv("DB_PASS")
	dbname := os.Getenv("DB_NAME")
	serverport := os.Getenv("SERVER_PORT")

	dbstr := fmt.Sprintf("%s:%s@tcp(mysql:3306)/%s?charset=utf8mb4&parseTime=True&loc=Local", dbuser, dbpass, dbname)

	db, err := gorm.Open("mysql", dbstr)
	if err != nil {
		log.Fatalf("Got error when connect database, the error is '%v'", err)
	}
	r := gin.Default()
	r.Use(SetDBtoContext(db))
	r.Use(cors.Default())

    {{range .ModelsGo}}
    r.GET("/{{.Name|toUrl}}", List{{.Name|snakeToCamel }})
   	r.POST("/{{.Name|toUrl}}", Create{{.Name|snakeToCamel }})
   	r.GET("/{{.Name|toUrl}}/:id", Read{{.Name|snakeToCamel }})
   	r.PUT("/{{.Name|toUrl}}/:id", Update{{.Name|snakeToCamel }})
   	r.DELETE("/{{.Name|toUrl}}/:id", Delete{{.Name|snakeToCamel }})
    {{end}}
    {{range .RelationsGo}}
    r.GET("/{{.Name|toUrl}}", Read{{.Name|snakeToCamel }})
    r.POST("/{{.Name|toUrl}}", Create{{.Name|snakeToCamel }})
    r.DELETE("/{{.Name|toUrl}}", Delete{{.Name|snakeToCamel }})
    {{end}}

	r.Run(":" + serverport)
}
{{range .ModelsGo}}

func List{{.Name|snakeToCamel }}(c *gin.Context) {
	db := DBInstance(c)
	var list{{.Name|snakeToCamel }} []{{.Name|snakeToCamel }}
	query := "SELECT * FROM {{.Name }} limit 10;"
	db.Raw(query).Scan(&list{{.Name|snakeToCamel }})
    c.Header("X-Total-Count", "10")
    c.Header("Access-Control-Expose-Headers", "*")
    c.JSON(200, list{{.Name|snakeToCamel }})
}

func Create{{.Name|snakeToCamel }}(c *gin.Context) {
	db := DBInstance(c)
	var {{.Name }} {{.Name|snakeToCamel }}

	if err := c.Bind(&{{.Name }}); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	if err := db.Create(&{{.Name }}).Error; err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	c.JSON(201, {{.Name }})
}

func Read{{.Name|snakeToCamel }}(c *gin.Context) {
	db := DBInstance(c)
	id := c.Params.ByName("id")
	var {{.Name }} {{.Name|snakeToCamel }}
	if db.First(&{{.Name }}, id).Error != nil {
		content := gin.H{"error": "{{.Name }} with id#" + id + " not found"}
		c.JSON(404, content)
		return
	}
	c.JSON(200, {{.Name }})
}

func Update{{.Name|snakeToCamel }}(c *gin.Context) {
	db := DBInstance(c)
	id := c.Params.ByName("id")
	var {{.Name }} {{.Name|snakeToCamel }}
	if db.First(&{{.Name }}, id).Error != nil {
		content := gin.H{"error": "{{.Name }} with id#" + id + " not found"}
		c.JSON(404, content)
		return
	}

	if err := c.Bind(&{{.Name }}); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	if err := db.Save(&{{.Name }}).Error; err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, {{.Name }})

}

func Delete{{.Name|snakeToCamel }}(c *gin.Context) {
	db := DBInstance(c)
	id := c.Params.ByName("id")
	var {{.Name }} {{.Name|snakeToCamel }}
	if db.First(&{{.Name }}, id).Error != nil {
		content := gin.H{"error": "{{.Name }} with id#" + id + " not found"}
		c.JSON(404, content)
		return
	}
	if err := db.Delete(&{{.Name }}).Error; err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}
	c.JSON(204, "deleted")
}
{{end}}
{{range .RelationsGo}}
{{ $relationName := .Name|fieldVarName }}
func Read{{.Name|snakeToCamel }}(c *gin.Context) {
	db := DBInstance(c)

    {{range .Fields}}
	{{.Name|fieldVarName }}, is{{.Name|snakeToCamel }} := c.GetQuery("{{.Name}}")
	{{end}}

	var list []{{.Name|snakeToCamel }}
	query := "SELECT * FROM {{.Name}} where 1"

    {{range .Fields}}
	if  is{{.Name|snakeToCamel }} {
		query = fmt.Sprintf("%s and {{.Name }} = %s ", query, {{.Name|fieldVarName }})
	}
	{{end}}

	db.Raw(query).Scan(&list)
	c.JSON(200, list)
}

func Create{{.Name|snakeToCamel }}(c *gin.Context) {
    db := DBInstance(c)
	var {{.Name|fieldVarName }} {{.Name|snakeToCamel }}
	if err := c.Bind(&{{.Name|fieldVarName }}); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}
	if err := db.Create(&{{.Name|fieldVarName }}).Error; err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	c.JSON(201, {{.Name|fieldVarName }})
}

func Delete{{.Name|snakeToCamel }}(c *gin.Context) {
    db := DBInstance(c)
    var {{$relationName}} {{.Name|snakeToCamel }}
    if err := c.Bind(&{{.Name|fieldVarName}}); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }

    query := "DELETE FROM {{.Name}} where 1"

    {{range .Fields}}
    query = fmt.Sprintf("%s and {{.Name}} = %d ", query, {{$relationName}}.{{.Name|snakeToCamel}})
    {{end}}

    db.Exec(query)
    c.JSON(200, "deleted")
}
{{end}}

func SetDBtoContext(db *gorm.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Set("DB", db)
		c.Next()
	}
}

func DBInstance(c *gin.Context) *gorm.DB {
	return c.MustGet("DB").(*gorm.DB)
}
