package main

import (
	"fmt"
	"time"
	"github.com/joho/godotenv"
	"github.com/gin-gonic/gin"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
	"log"
	"os"
)

{{range .ModelsGo}}
type {{.Name|snakeToCamel}} struct {
{{range .Fields}} {{ .Name|snakeToCamel }} {{ .GoType }} `json:"{{ .Name }}"`
{{end}}}
func ({{.Name|snakeToCamel}}) TableName() string {
	return "{{.Name}}"
}
{{end}}


{{range .VoGo}}
type {{.Name|snakeToCamel}} struct {
{{range .Fields}} {{ .Name|snakeToCamel }} {{ .GoType }}
{{end}}}
{{end}}

func main() {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}
	dbport := os.Getenv("DB_PORT")
	dbuser := os.Getenv("DB_USER")
	dbpass := os.Getenv("DB_PASS")
	dbname := os.Getenv("DB_NAME")
	serverport := os.Getenv("SERVER_PORT")

	dbstr := fmt.Sprintf("%s:%s@tcp(127.0.0.1:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local", dbuser, dbpass, dbport, dbname)

	db, err := gorm.Open("mysql", dbstr)
	if err != nil {
		log.Fatalf("Got error when connect database, the error is '%v'", err)
	}

	r := gin.Default()
	r.Use(SetDBtoContext(db))

    {{range .ModelsGo}}
    r.GET("/{{.Name}}", List{{.Name|snakeToCamel }})
   	r.POST("/{{.Name}}", Create{{.Name|snakeToCamel }})
   	r.GET("/{{.Name}}/:id", Read{{.Name|snakeToCamel }})
   	r.PUT("/{{.Name}}/:id", Update{{.Name|snakeToCamel }})
   	r.DELETE("/{{.Name}}/:id", Delete{{.Name|snakeToCamel }})
    {{end}}

	r.Run(":" + serverport)
}
{{range .ModelsGo}}

func List{{.Name|snakeToCamel }}(c *gin.Context) {
	db := DBInstance(c)
	var list{{.Name|snakeToCamel }} []{{.Name|snakeToCamel }}
	query := "SELECT * FROM {{.Name }} limit 10;"
	db.Raw(query).Scan(&list{{.Name|snakeToCamel }})
	c.JSON(200, list{{.Name|snakeToCamel }})
}

func Create{{.Name|snakeToCamel }}(c *gin.Context) {
	db := DBInstance(c)
	var {{.Name }} {{.Name|snakeToCamel }}

	if err := c.Bind(&{{.Name }}); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	if err := db.Create(&{{.Name }}).Error; err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	c.JSON(201, {{.Name }})
}

func Read{{.Name|snakeToCamel }}(c *gin.Context) {
	db := DBInstance(c)
	id := c.Params.ByName("id")
	var {{.Name }} {{.Name|snakeToCamel }}
	if db.First(&{{.Name }}, id).Error != nil {
		content := gin.H{"error": "{{.Name }} with id#" + id + " not found"}
		c.JSON(404, content)
		return
	}
	c.JSON(200, {{.Name }})
}

func Update{{.Name|snakeToCamel }}(c *gin.Context) {
	db := DBInstance(c)
	id := c.Params.ByName("id")
	var {{.Name }} {{.Name|snakeToCamel }}
	if db.First(&{{.Name }}, id).Error != nil {
		content := gin.H{"error": "{{.Name }} with id#" + id + " not found"}
		c.JSON(404, content)
		return
	}

	if err := c.Bind(&{{.Name }}); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	if err := db.Save(&{{.Name }}).Error; err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, {{.Name }})

}

func Delete{{.Name|snakeToCamel }}(c *gin.Context) {
	db := DBInstance(c)
	id := c.Params.ByName("id")
	var {{.Name }} {{.Name|snakeToCamel }}
	if db.First(&{{.Name }}, id).Error != nil {
		content := gin.H{"error": "{{.Name }} with id#" + id + " not found"}
		c.JSON(404, content)
		return
	}
	if err := db.Delete(&{{.Name }}).Error; err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}
	c.JSON(204, "deleted")
}

{{end}}


func SetDBtoContext(db *gorm.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Set("DB", db)
		c.Next()
	}
}

func DBInstance(c *gin.Context) *gorm.DB {
	return c.MustGet("DB").(*gorm.DB)
}
